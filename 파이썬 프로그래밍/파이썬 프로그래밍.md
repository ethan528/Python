# Python

# 변수의 이해

## 변수와 값
- 변수 = 값
- 변수에 값을 넣어라

## 변수와 메모리
- 변수의 값이 저장되는 공간을 메모리, 변수의 저장 위치를 메모리 주소라고 한다
- 변수에 들어가는 값은 반드시 어떤 특정 메모리 주소에 할당
- 변수를 선언하여 값을 저장할 때 운영체제 os 와 파이썬 인터프리터가 서로 협력하여 선언한 변수를 메모리 공간 어딘가에 저장하면서 메모리 주소를 공유

## 변수명 선언
- 변수명은 의미 있는 이름으로 하는 것이 좋다
- 일반적으로 파이썬의 모든 변수명은 소문자로 구성하는 것을 추천
- 특별한 의미가 있는 예약어는 변수명으로 사용할 수 없다

# 자료형과 기본 연산

## 기본 자료형
- 정수형 = 자연수를 포함해 값의 영역이 정수로 한정된 값
- 실수형 = 소수점이 포함된 값, 실제 값이 정수형이라도 9.0으로 입력하면 인터프리터는 실수형으로 해석
- 문자형 = 값이 문자로 출력되는 자료형, 따옴표에 들어간 정보를 문자형 데이터라고 함
- 불린형 = 논리형이라고도 하며, 참 또는 거짓을 표현할 때 사용, True=참=1, false=거짓=0

## 간단한 연산
- 더히기 = +
- 빼기 = -
- 곱하기 = *
- 나누기 = /
- 제곱승 = **
- 몫 = //
- 나머지 = %
- 증가 연산 = a += 1(a = a + 1)
- 감소 연산 = a -= 1(a = a - 1)

# 자료형 변환

## 정수형과 실수형 간 변환
- float(), 실수형으로 나누기
- int(), 소수점 이하의 내림 발생

## 숫자형과 문자형 간 변환
- str(), 문자형 간 덧셈은 단순 붙이기

## 자료형 확인하기
- type()

# 화면 입출력

입력 = input()

출력 = print()

# Lab: 화씨온도 변환기

```python 
print("본 프로그램은 섭씨온도를 화씨온도로 변환하는 프로그램입니다.")
pirnt("변환하고 싶은 서비씨온도를 입력하세요.")

celsius = input()
fahrenheit = (float(clesius) * 1.8) + 32

print("섭씨온도:", celsius)
print("화씨온도:", fahrenheit)
```

# 리스트의 이해

## 리스트의 개념
- 리스트는 하나의 변수에 여러 값을 할당하는 자료형 = 시퀀스 자료형(여러자료를 순서대로 넣는다는 뜻)

## 인덱싱과 슬라이싱

### 인덱싱
- 리스트에 있는 값에 접근하기 위해, 이 값의 상대적인 주소를 사용하는 것
- 첫 번째 값을 0으로 했을 때 이와 얼마나 덜어져 있는지를 표현한 값, 일반적으로 인덱스 주소 또는 인덱스 값이라고 함

```python
colors = ['red', 'blue', 'green']
print(colors[0]) # red
print(colors[1]) # green
print(len(colors)) # 3
```

### 슬라이싱
- 리스트의 인덱스를 사용하여 전체 리스트에서 일부를 잘라내여 반환

```python
cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
print(cities[0:6]) # ['서울', '부산', '인천', '대구', '대전', '광주']

print(cities[-8:0]) # ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
print(cities[-50:50])
# 범위를 넘어갈 경우 자동으로 최대 범위를 지정
#['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']

print(cities[::2])
# 2칸 단위로
# ['서울', '인천', '대전', '울산']
print(cities[::-1])
# 역으로 슬라이싱
# ['수원', '울산', '광주', '대전', '대군', '인천', '부산', '서울']

color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
print(color1 + color2) # ['red', 'blue', 'green', 'orange', 'black', 'white']
print(color1 * 2) # ['red', 'blue', 'green', 'red', 'blue', 'green']
print('blue' in color2) # False

color = ['red', 'blue', 'green']
color.append('white')
print(color) # ['red', 'blue', 'green', 'white']

color = ['red', 'blue', 'green']
color.extend(['black', 'purple']) # 리스트에 새로운 리스트 추가
print(color) # ['red', 'blue', 'green', 'black' 'purple']

color = ['red', 'blue', 'green']
color.insert(0, 'orange')
print(color) # ['orange', 'red, 'blue', 'green']

color = ['orange', 'red', 'blue', 'green']
color.remove('red')
print(color) # ['orange', 'blue', 'green']

color = ['red', 'blue', 'green']
color[0] = 'orange'
print(color) # ['orange', 'blue', 'green']
del color[0]
print(color) # ['blue', 'green']
```

## 패킹과 언패킹
- 시퀀스 자료형에서 일반적으로 사용할 수 있는 방법

```python
t = [1, 2, 3]
a, b, c = t
print(t, a, b, c) # [1, 2, 3] 1 2 3
```

## 이차원 리스트
- 행렬과 같은 개념

```python
kor_score = [49, 79, 20, 100, 80]
math_score = [43, 59, 85, 30, 90]
eng_score = [49, 79, 48, 60, 100]
midterm_score = [kor_score, math_score, eng_score]
print(midterm_score) # [[49, 79, 20, 100, 80], [43, 59, 85, 30, 90], [49, 79, 48, 60, 100]]
print(midterm_score[0][2]) # 20
```

# 리스트의 메모리 관리 방식


## 리스트의 메모리 저장

```python
kor_score = [49, 79, 20, 100, 80]
math_score = [43, 59, 85, 30, 90]
eng_score = [49, 79, 48, 60, 100]
midterm_score = [kor_score, math_score, eng_score]
math_score[0] = 1000
print(midterm_score) # [[49, 79, 20, 100, 80], [1000, 59, 85, 30, 90], [49, 79, 48, 60, 100]]
```

- 리스트 안에 값 자체를 저장하는 구조가 아니라, 값이 메모리에서 위치한 메모리의 주소값, 메모리 주소를 저장하는 것

## 메모리 저장 구롲로 인한 리스트의 특징

### 하나의 리스트에 다양한 자료형 포함 가능

```python
a = ["color", 1, 0.2]
```

### 리스트의 저장 방식
- 어떤 리스트값을 하나의 변수에 할당하는 순간, 두 변수는 같은 메모리 주소에 연결되게 된다.

# 조건문

## 조건문의 개념
- 조건문을 구성하기 위해서는 조건을 나타내는 기준과 실행해야 할 명령이 필요

## if-else 문
- if 뒤에는 참과 거짓을 판단할 수 있는 조건문이 들어가야 하고, 조건문이 끝나면 반드시 콜론을 붙여야 한다
- 들여쓰기를 사용하여 해당조건이 참일 경우 수행할 명령을 작성
- if 의 조건이 거짓을 경우 else 문이 수행된다

## 조건의 판단

### 비교 연산자
- <, > = ~보다 작다, ~보다 크다
- is, is not = 메모리 주소가 같다, 다르다
- ==, != = 값이 같다, 다르다
- <=, >= = 작거나 같다, 크거나 같다

### True 와 False 의 치환
- 컴퓨터는 기본적으로 이진수만 처리할 수 있으며, True 는 1로, False 는 0으로 처리한다.

### 논리 연산자
- and = 두 값이 모두 참일 경우 True, 아닐 경우 False
- or = 두 값 모두 거짓일 경우만 False
- not = 값을 역으로 반환하여 판단

### if-elif-else 문
- 중첩 if 문을 간단히 표현할 때 사용
- 여러 개의 조건을 검토할 수 있다

# Lab: 어떤 종류의 학생인지 맞히기

```python
print("당신이 태어난 연도를 입력하세요")
birth_year = input()
age = 2020 - int(birth_year) +1

if age <= 26 and age >= 20:
    print("대학생")
elif age < 20 and age >= 17:
    print("고등학생")
elif age < 17 and age >= 14:
    print("중학생")
elif age < 14 and age >= 8:
    print("초등학생")
else:
    print("학생이 아닙니다")
```

# 반복문

## 반복문의 개념
- 정해진 동작을 반복적으로 수행할 때 내리는 명령어

## for 문
- 반복 범위를 지정하여 반복을 수행

## while 문
- 어떤 조건이 만족하는 동안 명령 블록을 수행하고, 해당 조건이 거짓일 경우 더는 반복 명령문을 수행하지 않는 구문

## 반복문의 제어

### break 문
- 논리적으로 반복을 종료하는 방법

### continue 문
- 특정 조건에서 남은 명령을 건너뛰고 다음 반복문을 수행

### else 문
- 어떤 조건이 완전히 끝났을 때 한 번 더 실행해 주는 역할
- break 등으로 코드가 종료된 경우 else 문이 수행되지 않으므로, 해당 반복문이 완벽히 수행되었는지를 명시적으로 확인하기 위한 코드

# Lab: 구구단 계산기

```python
print("구구단 몇 단을 계산할까?")
user_input = input()
print("구구단", user_input, "단을 계산한다")
int_input = int(user_input)
for i in range(1, 10):
    result = int_input * i
    print(user_input, "x", i, "=", result)
```

# 조건문과 반복문 실습

## 문자열 역순 출력

```python
sentence = "I love you"
reverse_sentence = ''
for char in sentence:
    reverse_setence = char + reverse_sentence
print(reverse_sentence)
```

## 십진수를 이진수로 변환

```python
decimal = 10
result = ''
while (decimal > 0):
    remainder = decimal % 2
    decimal = decimal //2
    result = str(remainder) + result
print(result)
```

# Lab: 숫자 찾기 게임

```python
import random # 난수 발생 함수 호출
guess_number = random.randint(1, 100) # 1 ~ 100 사이 정수 난수 발생
print("숫자를 맞혀 보세요. (1 ~ 100)")
users_input = int(input()) # 사용자의 입력을 받음
while (users_intput is not guess_number): # 사용자 입력과 난수가 같은지 판단
    if users_input > guess_number: # 사용자 입력이 클 경우
        print("숫자가 너무 큽니다.")
    else: # 사용자 입력이 작을 경우
        print("숫자가 너무 작습니다.")
    users_input = int(input()) # 다시 사용자 입력을 받음
else:
    print("정답입니다.", "입력한 숫자는", 'users_input, "입니다.") # 종료 조건
```

# Lab: 연속적인 구구단 계산기

```python
print("구구단 몇 단을 계산할까요(1~9)?")
x = 1
while (x is not 0):
    x = int(inpt())
    if x == 0: break
    if not(1 <= x <= 9):
        print("잘못 입력했습니다", "1부터 9 사이 숫자를 입력하세요")
        continue
    else:
        print("구구단 " + str(x) + "단을 계산합니다.")
        for i in range(1,10):
            print(str(x) + " x " + str(i) + " = " + str(x*i))
        print("구구단 몇 단을 계산할까요(1~9)?")
print("구구단 게임을 종료합니다.")
```

# Lab: 평균 구하기

```python
kor_score = [49, 80, 20, 100, 80]
math_score = [43, 60, 85, 30, 90]
eng_score = [49, 82, 48, 50, 100]
midterm_score = [kor_score, math_score, eng_score]

student_score = [0, 0, 0, 0, 0]
i = 0
for subject in midterm_score:
    for score in subject:
        student_score[i] += score # 학생마다 개별로 교과 점수를 저장
        i += 1 # 학생 인덱스 구분
    i = 0 # 과목이 바뀔 때 학생 인덱스 초기화
else:
    a, b, c, d, e = student_score # 학생별 점수를 언패킹
    student_average = [a/3, b/3, c/3, d/3, e/3]
    print(student_average)
```

# 코드의 오류를 처리하는 방법

## 버그와 디버그
- 오류를 버그라고 하고, 오류를 수정하는 과정을 디버그라고 한다
- 오류를 만났을 때, 프로그램의 잘못을 찾아내고 고치는 것을 디버깅이라고 한다

## 오류의 종류와 해결 방법

### 문법적 오류
- 인터프리터가 해석을 못 해 코드 자체를 실행시키지 못하는 오류
- 대표적으로 들여쓰기 오류와 오탈자로 인한 오류가 있다

### 논리적 오류
- 코드를 제대로 작성했다고 생각했음에도, 원하는 결과가 나오지 않는 경우에 논리적 오류가 발생했을 가능성이 크다
- 확인이 필요한 변수들에 print() 함수를 사용해 값을 확인

# 함수 기초

## 함수의 개념과 장점
- 어떤 일을 수행하는 코드의 덩어리, 또는 코드의 묶음
- 필요할 때마다 호출 가능
- 논리적인 단위로 분할 가능
- 코드의 캡슐화

## 함수의 선언

```python
def 함수 이름 (매개변수 #1 ...):
    수행문 1
    수행문 2
    return <반환값>
```

## 함수의 실행 순서

```python
def 함수 이름 (매개변수1, 매개변수2):
    return 매개변수1 * 매개변수2

print(함수 이름(값1, 값2))
# 함수 호출 후 값1과 값2가 매개변수1과 매개변수2에 할당됨
# 매개변수1과 매개변수2 변수에 할당된 값이 함수 이름에 입력되 함수 코드에 의해 반환값 매개변수1 * 매개변수2가 반환됨
```

## 함수의 형태
- 반환값 없음, 매개변수 없음 = 함수 안 수행문만 수행
- 반환값 없음, 매개변수 있음 = 매개변수를 사용하여 수행문만 수행
- 반환값 있음, 매개변수 없음 = 매개변수 없이 수행문을 수행한 후, 결과값 반환
- 반환값 있음, 매개변수 있음 = 매개변수를 사용하여 수행문을 수행한 후, 결과값 반환

# 함수 심화

## 함수의 호출 방식
- 값에 의한 호출 = 인수를 넘길 때 값만 넘김
- 참조 호출 = 인수를 넘길 때 메모리 주소를 넘김
- 객체 호출 = 새로운 값을 할당하기 전까지는 기존에 넘어온 인수 객체의 주소값을 사용

## 변수의 사용 범위
- 지역 변수 = 함수 안에서만 사용
- 전역 변수 = 프로그램 전체에서 사용

## 재귀 함수
- 자기 자신을 다시 부르는 함수

# 함수의 인수

## 키워드 인수
- 함수에 입력되는 매개변수의 변수명을 사용하여 함수의 인수를 지정하는 방법

```python
def 함수 이름(매개변수1, 매개변수2):
    수행문1
    return 반환값

함수 이름(매개변수2 = 값2, 매개변수1 = 값1)
```

## 디폴트 인수
- 매개변수에 기본값을 지정하여 사용하고, 아무런 값도 인수로 넘기지 않으면 지정된 기본값을 사용하는 방식

```python
def 함수 이름(매개변수1, 매개변수2 = 기본값2):
    수행문1
    return 반환값

함수 이름(값1)
```

## 가변 인수
- 매개변수 개수가 정해지지 않고 진행해야 하는 경우
- 일반적인 키워드 인수가 끝난 후에 넣어야 한다
- 튜플 형태로 함수 안에서 인덱스를 사용해 변수에 접근 가능

```python
def 함수 이름(매개변수1, *args):
    return 매개변수1 + sum(*args)

print(함수 이름(값1, 값2, 값3, 값4))
# 값1 + sum(값2, 값3, 값4)
```

## 키워드 가변 인수
- 매개변수의 이름을 따로 지정하지 않고 입력하는 방법

```python
def 함수 이름(**kwargs):
    print(kwargs)
    print("{first}".format(**kwargs))
    print("{second}".format(**kwargs))
    print("{third}".format(**kwargs))

print(함수 이름(first = 3, second = 4, third = 5))
# {'first':3, 'second':4, 'third':5}
# 3
# 4
# 5
```

# 좋은 코드를 작성하는 방법

## 좋은 코드의 의미
- 많은 사람이 쉽게 읽을 수 있도록 가독성이 좋게 작성

## 코딩 규칙
- 들여쓰기는 4 스페이스
- 한 줄은 최대 79자까지
- 불필요한 공백은 피함
- 중요한 것은 일관성
- = 연산자는 1칸이상 띄우지 않는다
- 주석은 항상 갱신하고, 불필요한 주석은 삭제
- 소분자 l, 대문자 O, 대문자 I는 사용을 금한다
- 함수명은 소문자로 구성하고, 필요하면 밑줄로 나눈다

## 함수 개발 가이드라인

### 함수 이름
- 함수는 가능한 짧게 작성
- 함수 이름에 함수의 역할과 의도를 명확히 드러낼 것

### 함수의 역할
- 한 가지 역할을 명확히 해야 한다

### 함수를 만드는 경우
- 공통으로 사용되는 코드를 함수로 변환
- 복잡한 로직이 사용되었을 때, 식별 가능한 이름의 함수로 변환

# 문자열의 이해

## 문자열의 개념
- 문자열은 시퀀스 자료형
- 시퀀스 자료형 = 리스트와 같이 데이터를 순차적으로 메모리에 저장하는 형식의 데이터

## 문자열과 메모리 공간

```python
import sys
print(sys.getsizeof(문자열))
# 문자열의 메모리 크기 출력
```

- 문자를 이진수로 변환하여 메모리에 저장
- 문자를 처리하기 위해 이진수로 변환되는 표준 규칙을 만들었다
- 이러한 규칙을 인코딩이라고 한다
- 이러한 규칙을 이용하여 숫자와 문자를 맵핑하는 것이 바로 운영체제와 인터프리터의 역할 중 하나

## 문자열의 인덱싱
- 리스트처럼 글자 하나하나가 상대적인 주소를 가지는데 이 주소를 사용해 할당된 값을 가져오는 인덱싱을 사용할 수 있다

## 문자열의 슬라이싱
- 문자열의 주소값을 기반으로 문자열의 부분값을 반환하는 기법

## 문자열의 연산
- 모든 변수가 문자열일 경우 덧셈은 텍스트 붙이기를 실행
- 곱하기로 반복 연산
- in 연산으로 특정 문자가 특정 변수에 들어가 있는지 확인

## 문자열함수
- 문자열 함수를 사용하는 방법 = 문자열.문자열 함수

# Lab: 단어 카운팅

```python
f = open(yesterday.txt", 'r')
yesterday_lyric = f.readlines()
f.close()

contents = ""
for line in yesterday_lyric:
    contents = contents + line.strip() + "\n"

n_of_yesterday  = contents.upper().count("YESTERDAY")
print("Number of a Word 'Yesterday'", n_of_yesterday)
```

# 문자열 서식 지정

## 서식 지정의 개념
- 통화 단위, 세 자리 숫자 단위 띄어쓰기, % 출력 등 다양한 형식에 맞춰 출력할 일이 생기는데, 이를 서식 지정이라고 한다

## % 서식과 format() 함수

### % 서식
- '%자료형 % (값)'

```python
print("I eat %d apples." % 3)
print("I eat %s apples." % "five")
# I eat 3 apples.
# I eat five apples.

print("Product: %s, Price per unit: %f." % ("Apple", 5.243))
# Product: Apple, Price per unit: 5.243000.

number = 3
day = '"three"
print("I ate %d apples. I was sick for %s days." % (number, day))
# I ate 3 apples. I was sick for three days.
```

### format() 함수
- % 서식과 거의 같지만, 문자열 형태가 있는 함수를 사용한다는 차이점이 있다
- 문자열 서식은 함수이므로 다음과 같은 형태로 서식을 지정할 수 있다
- "{자료형}".format(인수)

```python
age = 40; name = 'Sungchul Choi'
print("I'm {0} years old.".format(age))
print("My name is {0} and {1} years old.".format(name, age))
print("Product: {0}, Price per unit: {1:.2f}.".format("apple", 5.243))
# I'm 40 years old.
My name is Sungchul Choi and 40 years old.
Product: Apple, Price per unit: 5.24.
```

## 패딩

### % 서식의 패딩

```python
print("%10d" % 12)
#         12
print("%-10d" % 12)
# 12

print("%10.3f" % 5.94343)
#      5.843
print("%10.2f" % 5.94343)
#       5.94
print("%-10.2f" % 5.94343)
# 5.94
```

### format() 함수의 패딩

```python
print("{0:>10s}".format("Apple"))
#     Apple
print("{0<10s}".format("Apple"))
# Apple

print("{1:10.5f}.".format("Apple", 5.243))
# '  5.24300.'
print("{1:>10.5f}.".format("Apple", 5.243))
# '  5.24300.'
print("{1:<10.5f}.".format("Apple", 5.243))
# '5.24300  .'
```

# 자료구조의 이해

## 자료구조의 개념
- 데이터의 특징을 고려하여 데이터를 저장하는 방법을 자료구조라고 한다
- 특징이 있는 정보를 메모리에 효율적으로 저장 및 반환하는 방법으로, 데이터를 관리하는 방식
- 대용량일수록 메모리에 빨리 저장하고 빠르게 검색하여, 메모리를 효율적으로 사용하고 실행 시간을 줄일 수 있게 해 준다

## 파이썬에서의 자료구조
- 스택 = last in first out
- 큐 = first in first out
- 튜플 = 리스트와 같지만, 데이터의 변경을 허용 안 함
- 세트 = 데이터 중복을 허용하지 않고, 수학의 집한 연산을 지원
- 딕셔너리 = 키와 값 형태의 데이터를 저장, 키값은 다른 데이터와 중복을 허용 안 함
- collections 모듈 = 위에 열거된 여러 자료구조를 효율적으로 사용할 수 있도록 지원하는 파이썬 내장 모듈

# 스택과 큐

## 스택
- 마지막에 들어간 데이터가 가장 먼저 나오는 형태로, 데이터의 저장 공간을 구현
- 데이터 저장 = 푸시
- 데이터 추출 = 팝

## 큐
- 스택은 메모리가 시작하는 지점이 고정되어 있지만, 큐는 처음 값이 저장되는 메모리 주소가 값이 사용됨에 따라 계속 바뀌게 되어 구현에 좀 더 신경을 써야 한다, 파이썬에서는 스스로 구현됨

# 튜플과 세트

## 튜플
- 값을 변경하는 것이 불가능한 리스트
- 리스트형 데이터에 사용하는 함수 모두 사용 가능

## 세트
- 값을 순서 없이 저장하면서 중복을 불허하는 자료형
- 수학의 집합과 개념적으로 비슷
- 삭제나 변경 가능
- add() = 원소 하나 추가
- remove(), discard() = 원소 하나 삭제
- update() = 새로운 리스트를 그대로 추가
- clear() = 모든 변수 삭제
- s1.union(s2), s1|s2 = 합집합
- s1.intersection(s2), s1&s2 = 교집합
- s1.difference(se), s1-s2 = 차집합

# 딕셔너리

## 딕셔너리의 개념
- 데이터의 유일한 구분자를 키라는 이름으로 검색할 수 있게 하고, 실제 데이터를 값이라는 이름으로 쌍으로 저장하여 프로그래머가 데이터를 쉽게 찾을 수 있는 체계

## 파이썬에서의 딕셔너리
- 다양한 자료형이 들어갈 수 있다
- 할당 시 사용되는 키가 기존에 있던 값이라면 값이 변경되고, 기존에 없던 값이면 새로운 값이 할당된다

## 딕셔너리의 함수
- keys() = 키만 출력
- values() = 값만 출력
- items() = 키-값 쌍 출력

# collections 모듈

## deque 모듈

```python
from collections import deque

deque_list = deque()
for i in range(5):
    deque_list.append(i)

print(deque_list)
# deque([0, 1, 2, 3, 4])

print(deque_lsit.pop())
# 4
print(deque_list)
# deque([0, 1, 2, 3])

print(deque_list.rotate(2))
# deque([2, 3, 0, 1])

print(deque(reverse(deque_list)))
# deque([1, 0, 2, 3])

deque_list.extend([4, 5, 6])
print(deque_list)
# deque([1, 0, 2, 3, 4, 5 ,6])
deque_list.extendleft([7, 8, 9])
print(deque_list)
# deque([7, 8, 9, 1, 0, 2, 3, 4, 5, 6])
```

## OrderedDict 모듈

```python
from collections import OrderedDict

d = OrderdDict()
d['x'] = 100
d['y'] = 200
d['z'] = 300
d['l'] = 500

for k, v in d.items():
    print(k, v)
# x 100
# y 200
# z 300
# l 500

def sort_by_key(t):
    return t[0]

for k, v in OrderDict(sorted(d.items(), key = sort_by_key)).items():
    print(k, v)
# l 500
# x 100
# y 200
# z 300
```

## defaultdict 모듈

```python
from collections import defaultdict

d = defaultdict(lambda: 0)
print(d["first"])
# 0

s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)

for k, v in s:
    d[k].append(v)

print(d.items())
# dict_items([('yellow', [1, 3]), ('blue', [2, 4]), ('red', [1])])
```

## Counter 모듈

```python
from collections import Counter

text = list("gallahad")
c = Coutner(text)
print(c)
# Counter({'a':3, 'l':2, 'g':1, 'h':1, 'd':1})
print(c["a"])
# 3

c = Counter({'red':4, 'blue':2})
print(c.elements()))
# ['red', 'red', 'red', 'red', 'blue', 'blue']

c = Counter(cats = 4, dogs = 8)
print(list(c.elements()))
# ['cats', 'cats', 'cats', 'cats', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs']

c = Counter(a = 4, b = 2, c = 0, d = -2)
d = Counter(a = 1, b = 2, c = 3, d = 4)
print(c.subtract(d)) # c - d
# Counter({'a':3, 'b':0, 'c':-3, 'd':-6})

print(c + d)
# Counter({'a':5, 'b':4, 'c':3, 'd':2})
print(c & d)
# Counter({'b':2, 'a':1})
print(c | d)
# Counter({'a':4, 'd':4, 'c':3, 'b': 2})
```

## namedtuple 모듈

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(11, y=22)
print(p)
# Point(x=11, y=22)
print(p.x, p.y)
# (11, 22)
print(p[0] + p[1])
# 33
```

# Lab: 텍스트 마이닝 프로그램

```python
text = """A press lelease is the quickest and easiest way to get free publicity. If well written, a press release can result in multiple published articles about your firm and its products. And that can mean new prospects contaacting you asking you to sell to them.""".lower().split()

from collections import defaultdict

word_count = defaultdict(lambda: 0)
for word in text:
    word_count[word] += 1

from collections import OrderDict
for i, v in OrderedDict(sorted(word_count.items(), keylambda t: t[1], reverse=True)).items():
    print(i, v)
```

# 파이썬 스타일 코드의 이해

## 파이썬 스타일 코드의 개념

```python
colors = ['red', 'blue', 'green', 'yellow']
result = ''
for s in colors:
    result += s
print(result)
# redbluegreenyellow

result = ''.join(colors)
print(result)
# redbluegreenyellow
```

## 파이썬 스타일 코드를 사용하는 이유
- split(), join(), list comprehension, enumerate(), zip()같은 기본적인 개념부터 map()과 reduce()처럼 상위 개념까지 포함
- 다른 사람이 작성한 코드를 이해할 때 용이

# 문자열의 분리 및 결합

## 문자열의 분리: split() 함수

```python
items = 'zero one two three'.split()
print(items)
# ['zero', 'one', 'two', 'three']
```
