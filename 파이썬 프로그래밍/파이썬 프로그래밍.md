# 파이썬 프로그래밍

# 변수의 이해

## 변수와 값
- 변수 = 값
- 변수에 값을 넣어라

## 변수와 메모리
- 변수의 값이 저장되는 공간을 메모리, 변수의 저장 위치를 메모리 주소라고 한다
- 변수에 들어가는 값은 반드시 어떤 특정 메모리 주소에 할당
- 변수를 선언하여 값을 저장할 때 운영체제 os 와 파이썬 인터프리터가 서로 협력하여 선언한 변수를 메모리 공간 어딘가에 저장하면서 메모리 주소를 공유

## 변수명 선언
- 변수명은 의미 있는 이름으로 하는 것이 좋다
- 일반적으로 파이썬의 모든 변수명은 소문자로 구성하는 것을 추천
- 특별한 의미가 있는 예약어는 변수명으로 사용할 수 없다

# 자료형과 기본 연산

## 기본 자료형
- 정수형 = 자연수를 포함해 값의 영역이 정수로 한정된 값
- 실수형 = 소수점이 포함된 값, 실제 값이 정수형이라도 9.0으로 입력하면 인터프리터는 실수형으로 해석
- 문자형 = 값이 문자로 출력되는 자료형, 따옴표에 들어간 정보를 문자형 데이터라고 함
- 불린형 = 논리형이라고도 하며, 참 또는 거짓을 표현할 때 사용, True=참=1, false=거짓=0

## 간단한 연산
- 더히기 = +
- 빼기 = -
- 곱하기 = *
- 나누기 = /
- 제곱승 = **
- 몫 = //
- 나머지 = %
- 증가 연산 = a += 1(a = a + 1)
- 감소 연산 = a -= 1(a = a - 1)

# 자료형 변환

## 정수형과 실수형 간 변환
- float(), 실수형으로 나누기
- int(), 소수점 이하의 내림 발생

## 숫자형과 문자형 간 변환
- str(), 문자형 간 덧셈은 단순 붙이기

## 자료형 확인하기
- type()

# 화면 입출력

입력 = input()

출력 = print()

# Lab: 화씨온도 변환기

```python 
print("본 프로그램은 섭씨온도를 화씨온도로 변환하는 프로그램입니다.")
pirnt("변환하고 싶은 서비씨온도를 입력하세요.")

celsius = input()
fahrenheit = (float(clesius) * 1.8) + 32

print("섭씨온도:", celsius)
print("화씨온도:", fahrenheit)
```

# 리스트의 이해

## 리스트의 개념
- 리스트는 하나의 변수에 여러 값을 할당하는 자료형 = 시퀀스 자료형(여러자료를 순서대로 넣는다는 뜻)

## 인덱싱과 슬라이싱

### 인덱싱
- 리스트에 있는 값에 접근하기 위해, 이 값의 상대적인 주소를 사용하는 것
- 첫 번째 값을 0으로 했을 때 이와 얼마나 덜어져 있는지를 표현한 값, 일반적으로 인덱스 주소 또는 인덱스 값이라고 함

```python
colors = ['red', 'blue', 'green']
print(colors[0]) # red
print(colors[1]) # green
print(len(colors)) # 3
```

### 슬라이싱
- 리스트의 인덱스를 사용하여 전체 리스트에서 일부를 잘라내여 반환

```python
cities = ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
print(cities[0:6]) # ['서울', '부산', '인천', '대구', '대전', '광주']

print(cities[-8:0]) # ['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']
print(cities[-50:50])
# 범위를 넘어갈 경우 자동으로 최대 범위를 지정
#['서울', '부산', '인천', '대구', '대전', '광주', '울산', '수원']

print(cities[::2])
# 2칸 단위로
# ['서울', '인천', '대전', '울산']
print(cities[::-1])
# 역으로 슬라이싱
# ['수원', '울산', '광주', '대전', '대군', '인천', '부산', '서울']

color1 = ['red', 'blue', 'green']
color2 = ['orange', 'black', 'white']
print(color1 + color2) # ['red', 'blue', 'green', 'orange', 'black', 'white']
print(color1 * 2) # ['red', 'blue', 'green', 'red', 'blue', 'green']
print('blue' in color2) # False

color = ['red', 'blue', 'green']
color.append('white')
print(color) # ['red', 'blue', 'green', 'white']

color = ['red', 'blue', 'green']
color.extend(['black', 'purple']) # 리스트에 새로운 리스트 추가
print(color) # ['red', 'blue', 'green', 'black' 'purple']

color = ['red', 'blue', 'green']
color.insert(0, 'orange')
print(color) # ['orange', 'red, 'blue', 'green']

color = ['orange', 'red', 'blue', 'green']
color.remove('red')
print(color) # ['orange', 'blue', 'green']

color = ['red', 'blue', 'green']
color[0] = 'orange'
print(color) # ['orange', 'blue', 'green']
del color[0]
print(color) # ['blue', 'green']
```

## 패킹과 언패킹
- 시퀀스 자료형에서 일반적으로 사용할 수 있는 방법

```python
t = [1, 2, 3] # 1, 2, 3을 변수 t 에 패킹
a, b, c = t # t 에 있는 값 1, 2, 3을 변수 a, b, c 에 언패킹
print(t, a, b, c) # [1, 2, 3] 1 2 3
```

## 이차원 리스트
- 행렬과 같은 개념

```python
kor_score = [49, 79, 20, 100, 80]
math_score = [43, 59, 85, 30, 90]
eng_score = [49, 79, 48, 60, 100]
midterm_score = [kor_score, math_score, eng_score]
print(midterm_score) # [[49, 79, 20, 100, 80], [43, 59, 85, 30, 90], [49, 79, 48, 60, 100]]
print(midterm_score[0][2]) # 20
```

# 리스트의 메모리 관리 방식


## 리스트의 메모리 저장

```python
kor_score = [49, 79, 20, 100, 80]
math_score = [43, 59, 85, 30, 90]
eng_score = [49, 79, 48, 60, 100]
midterm_score = [kor_score, math_score, eng_score]
math_score[0] = 1000
print(midterm_score) # [[49, 79, 20, 100, 80], [1000, 59, 85, 30, 90], [49, 79, 48, 60, 100]]
```

- 리스트 안에 값 자체를 저장하는 구조가 아니라, 값이 메모리에서 위치한 메모리의 주소값, 메모리 주소를 저장하는 것

## 메모리 저장 구롲로 인한 리스트의 특징

### 하나의 리스트에 다양한 자료형 포함 가능

```python
a = ["color", 1, 0.2]
```

### 리스트의 저장 방식
- 어떤 리스트값을 하나의 변수에 할당하는 순간, 두 변수는 같은 메모리 주소에 연결되게 된다.

# 조건문

## 조건문의 개념
- 조건문을 구성하기 위해서는 조건을 나타내는 기준과 실행해야 할 명령이 필요

## if-else 문
- if 뒤에는 참과 거짓을 판단할 수 있는 조건문이 들어가야 하고, 조건문이 끝나면 반드시 콜론을 붙여야 한다
- 들여쓰기를 사용하여 해당조건이 참일 경우 수행할 명령을 작성
- if 의 조건이 거짓을 경우 else 문이 수행된다

## 조건의 판단

### 비교 연산자
- <, > = ~보다 작다, ~보다 크다
- is, is not = 메모리 주소가 같다, 다르다
- ==, != = 값이 같다, 다르다
- <=, >= = 작거나 같다, 크거나 같다

### True 와 False 의 치환
- 컴퓨터는 기본적으로 이진수만 처리할 수 있으며, True 는 1로, False 는 0으로 처리한다.

### 논리 연산자
- and = 두 값이 모두 참일 경우 True, 아닐 경우 False
- or = 두 값 모두 거짓일 경우만 False
- not = 값을 역으로 반환하여 판단

### if-elif-else 문
- 중첩 if 문을 간단히 표현할 때 사용
- 여러 개의 조건을 검토할 수 있다

# Lab: 어떤 종류의 학생인지 맞히기

```python
print("당신이 태어난 연도를 입력하세요")
birth_year = input()
age = 2020 - int(birth_year) +1

if age <= 26 and age >= 20:
    print("대학생")
elif age < 20 and age >= 17:
    print("고등학생")
elif age < 17 and age >= 14:
    print("중학생")
elif age < 14 and age >= 8:
    print("초등학생")
else:
    print("학생이 아닙니다")
```

# 반복문

## 반복문의 개념
- 정해진 동작을 반복적으로 수행할 때 내리는 명령어

## for 문
- 반복 범위를 지정하여 반복을 수행

## while 문
- 어떤 조건이 만족하는 동안 명령 블록을 수행하고, 해당 조건이 거짓일 경우 더는 반복 명령문을 수행하지 않는 구문

## 반복문의 제어

### break 문
- 논리적으로 반복을 종료하는 방법

### continue 문
- 특정 조건에서 남은 명령을 건너뛰고 다음 반복문을 수행

### else 문
- 어떤 조건이 완전히 끝났을 때 한 번 더 실행해 주는 역할
- break 등으로 코드가 종료된 경우 else 문이 수행되지 않으므로, 해당 반복문이 완벽히 수행되었는지를 명시적으로 확인하기 위한 코드

# Lab: 구구단 계산기

```python
print("구구단 몇 단을 계산할까?")
user_input = input()
print("구구단", user_input, "단을 계산한다")
int_input = int(user_input)
for i in range(1, 10):
    result = int_input * i
    print(user_input, "x", i, "=", result)
```

# 조건문과 반복문 실습

## 문자열 역순 출력

```python
sentence = "I love you"
reverse_sentence = ''
for char in sentence:
    reverse_setence = char + reverse_sentence
print(reverse_sentence)
```

## 십진수를 이진수로 변환

```python
decimal = 10
result = ''
while (decimal > 0):
    remainder = decimal % 2
    decimal = decimal //2
    result = str(remainder) + result
print(result)
```

# Lab: 숫자 찾기 게임

```python
import random # 난수 발생 함수 호출
guess_number = random.randint(1, 100) # 1 ~ 100 사이 정수 난수 발생
print("숫자를 맞혀 보세요. (1 ~ 100)")
users_input = int(input()) # 사용자의 입력을 받음
while (users_intput is not guess_number): # 사용자 입력과 난수가 같은지 판단
    if users_input > guess_number: # 사용자 입력이 클 경우
        print("숫자가 너무 큽니다.")
    else: # 사용자 입력이 작을 경우
        print("숫자가 너무 작습니다.")
    users_input = int(input()) # 다시 사용자 입력을 받음
else:
    print("정답입니다.", "입력한 숫자는", 'users_input, "입니다.") # 종료 조건
```

# Lab: 연속적인 구구단 계산기

```python
print("구구단 몇 단을 계산할까요(1~9)?")
x = 1
while (x is not 0):
    x = int(inpt())
    if x == 0: break
    if not(1 <= x <= 9):
        print("잘못 입력했습니다", "1부터 9 사이 숫자를 입력하세요")
        continue
    else:
        print("구구단 " + str(x) + "단을 계산합니다.")
        for i in range(1,10):
            print(str(x) + " x " + str(i) + " = " + str(x*i))
        print("구구단 몇 단을 계산할까요(1~9)?")
print("구구단 게임을 종료합니다.")
```

# Lab: 평균 구하기

```python
kor_score = [49, 80, 20, 100, 80]
math_score = [43, 60, 85, 30, 90]
eng_score = [49, 82, 48, 50, 100]
midterm_score = [kor_score, math_score, eng_score]

student_score = [0, 0, 0, 0, 0]
i = 0
for subject in midterm_score:
    for score in subject:
        student_score[i] += score # 학생마다 개별로 교과 점수를 저장
        i += 1 # 학생 인덱스 구분
    i = 0 # 과목이 바뀔 때 학생 인덱스 초기화
else:
    a, b, c, d, e = student_score # 학생별 점수를 언패킹
    student_average = [a/3, b/3, c/3, d/3, e/3]
    print(student_average)
```

# 코드의 오류를 처리하는 방법

## 버그와 디버그
- 오류를 버그라고 하고, 오류를 수정하는 과정을 디버그라고 한다
- 오류를 만났을 때, 프로그램의 잘못을 찾아내고 고치는 것을 디버깅이라고 한다

## 오류의 종류와 해결 방법

### 문법적 오류
- 인터프리터가 해석을 못 해 코드 자체를 실행시키지 못하는 오류
- 대표적으로 들여쓰기 오류와 오탈자로 인한 오류가 있다

### 논리적 오류
- 코드를 제대로 작성했다고 생각했음에도, 원하는 결과가 나오지 않는 경우에 논리적 오류가 발생했을 가능성이 크다
- 확인이 필요한 변수들에 print() 함수를 사용해 값을 확인

# 함수 기초

## 함수의 개념과 장점
- 어떤 일을 수행하는 코드의 덩어리, 또는 코드의 묶음
- 필요할 때마다 호출 가능
- 논리적인 단위로 분할 가능
- 코드의 캡슐화

## 함수의 선언

```python
def 함수 이름 (매개변수 #1 ...):
    수행문 1
    수행문 2
    return <반환값>
```

## 함수의 실행 순서

```python
def 함수 이름 (매개변수1, 매개변수2):
    return 매개변수1 * 매개변수2

print(함수 이름(값1, 값2))
# 함수 호출 후 값1과 값2가 매개변수1과 매개변수2에 할당됨
# 매개변수1과 매개변수2 변수에 할당된 값이 함수 이름에 입력되 함수 코드에 의해 반환값 매개변수1 * 매개변수2가 반환됨
```

## 함수의 형태
- 반환값 없음, 매개변수 없음 = 함수 안 수행문만 수행
- 반환값 없음, 매개변수 있음 = 매개변수를 사용하여 수행문만 수행
- 반환값 있음, 매개변수 없음 = 매개변수 없이 수행문을 수행한 후, 결과값 반환
- 반환값 있음, 매개변수 있음 = 매개변수를 사용하여 수행문을 수행한 후, 결과값 반환

# 함수 심화

## 함수의 호출 방식
- 값에 의한 호출 = 인수를 넘길 때 값만 넘김
- 참조 호출 = 인수를 넘길 때 메모리 주소를 넘김
- 객체 호출 = 새로운 값을 할당하기 전까지는 기존에 넘어온 인수 객체의 주소값을 사용

## 변수의 사용 범위
- 지역 변수 = 함수 안에서만 사용
- 전역 변수 = 프로그램 전체에서 사용

## 재귀 함수
- 자기 자신을 다시 부르는 함수

# 함수의 인수

## 키워드 인수
- 함수에 입력되는 매개변수의 변수명을 사용하여 함수의 인수를 지정하는 방법

```python
def 함수 이름(매개변수1, 매개변수2):
    수행문1
    return 반환값

함수 이름(매개변수2 = 값2, 매개변수1 = 값1)
```

## 디폴트 인수
- 매개변수에 기본값을 지정하여 사용하고, 아무런 값도 인수로 넘기지 않으면 지정된 기본값을 사용하는 방식

```python
def 함수 이름(매개변수1, 매개변수2 = 기본값2):
    수행문1
    return 반환값

함수 이름(값1)
```

## 가변 인수
- 매개변수 개수가 정해지지 않고 진행해야 하는 경우
- 일반적인 키워드 인수가 끝난 후에 넣어야 한다
- 튜플 형태로 함수 안에서 인덱스를 사용해 변수에 접근 가능

```python
def 함수 이름(매개변수1, *args):
    return 매개변수1 + sum(*args)

print(함수 이름(값1, 값2, 값3, 값4))
# 값1 + sum(값2, 값3, 값4)
```

## 키워드 가변 인수
- 매개변수의 이름을 따로 지정하지 않고 입력하는 방법

```python
def 함수 이름(**kwargs):
    print(kwargs)
    print("{first}".format(**kwargs))
    print("{second}".format(**kwargs))
    print("{third}".format(**kwargs))

함수 이름(first = 3, second = 4, third = 5)
# {'first':3, 'second':4, 'third':5}
# 3
# 4
# 5
```

# 좋은 코드를 작성하는 방법

## 좋은 코드의 의미
- 많은 사람이 쉽게 읽을 수 있도록 가독성이 좋게 작성

## 코딩 규칙
- 들여쓰기는 4 스페이스
- 한 줄은 최대 79자까지
- 불필요한 공백은 피함
- 중요한 것은 일관성
- = 연산자는 1칸이상 띄우지 않는다
- 주석은 항상 갱신하고, 불필요한 주석은 삭제
- 소분자 l, 대문자 O, 대문자 I는 사용을 금한다
- 함수명은 소문자로 구성하고, 필요하면 밑줄로 나눈다

## 함수 개발 가이드라인

### 함수 이름
- 함수는 가능한 짧게 작성
- 함수 이름에 함수의 역할과 의도를 명확히 드러낼 것

### 함수의 역할
- 한 가지 역할을 명확히 해야 한다

### 함수를 만드는 경우
- 공통으로 사용되는 코드를 함수로 변환
- 복잡한 로직이 사용되었을 때, 식별 가능한 이름의 함수로 변환

# 문자열의 이해

## 문자열의 개념
- 문자열은 시퀀스 자료형
- 시퀀스 자료형 = 리스트와 같이 데이터를 순차적으로 메모리에 저장하는 형식의 데이터

## 문자열과 메모리 공간

```python
import sys
print(sys.getsizeof(문자열))
# 문자열의 메모리 크기 출력
```

- 문자를 이진수로 변환하여 메모리에 저장
- 문자를 처리하기 위해 이진수로 변환되는 표준 규칙을 만들었다
- 이러한 규칙을 인코딩이라고 한다
- 이러한 규칙을 이용하여 숫자와 문자를 맵핑하는 것이 바로 운영체제와 인터프리터의 역할 중 하나

## 문자열의 인덱싱
- 리스트처럼 글자 하나하나가 상대적인 주소를 가지는데 이 주소를 사용해 할당된 값을 가져오는 인덱싱을 사용할 수 있다

## 문자열의 슬라이싱
- 문자열의 주소값을 기반으로 문자열의 부분값을 반환하는 기법

## 문자열의 연산
- 모든 변수가 문자열일 경우 덧셈은 텍스트 붙이기를 실행
- 곱하기로 반복 연산
- in 연산으로 특정 문자가 특정 변수에 들어가 있는지 확인

## 문자열함수
- 문자열 함수를 사용하는 방법 = 문자열.문자열 함수

# Lab: 단어 카운팅

```python
f = open(yesterday.txt", 'r')
yesterday_lyric = f.readlines()
f.close()

contents = ""
for line in yesterday_lyric:
    contents = contents + line.strip() + "\n"

n_of_yesterday  = contents.upper().count("YESTERDAY")
print("Number of a Word 'Yesterday'", n_of_yesterday)
```

# 문자열 서식 지정

## 서식 지정의 개념
- 통화 단위, 세 자리 숫자 단위 띄어쓰기, % 출력 등 다양한 형식에 맞춰 출력할 일이 생기는데, 이를 서식 지정이라고 한다

## % 서식과 format() 함수

### % 서식
- '%자료형 % (값)'

```python
print("I eat %d apples." % 3)
print("I eat %s apples." % "five")
# I eat 3 apples.
# I eat five apples.

print("Product: %s, Price per unit: %f." % ("Apple", 5.243))
# Product: Apple, Price per unit: 5.243000.

number = 3
day = '"three"
print("I ate %d apples. I was sick for %s days." % (number, day))
# I ate 3 apples. I was sick for three days.
```

### format() 함수
- % 서식과 거의 같지만, 문자열 형태가 있는 함수를 사용한다는 차이점이 있다
- 문자열 서식은 함수이므로 다음과 같은 형태로 서식을 지정할 수 있다
- "{자료형}".format(인수)

```python
age = 40; name = 'Sungchul Choi'
print("I'm {0} years old.".format(age))
print("My name is {0} and {1} years old.".format(name, age))
print("Product: {0}, Price per unit: {1:.2f}.".format("apple", 5.243))
# I'm 40 years old.
My name is Sungchul Choi and 40 years old.
Product: Apple, Price per unit: 5.24.
```

## 패딩

### % 서식의 패딩

```python
print("%10d" % 12)
#         12
print("%-10d" % 12)
# 12

print("%10.3f" % 5.94343)
#      5.843
print("%10.2f" % 5.94343)
#       5.94
print("%-10.2f" % 5.94343)
# 5.94
```

### format() 함수의 패딩

```python
print("{0:>10s}".format("Apple"))
#     Apple
print("{0<10s}".format("Apple"))
# Apple

print("{1:10.5f}.".format("Apple", 5.243))
# '  5.24300.'
print("{1:>10.5f}.".format("Apple", 5.243))
# '  5.24300.'
print("{1:<10.5f}.".format("Apple", 5.243))
# '5.24300  .'
```

# 자료구조의 이해

## 자료구조의 개념
- 데이터의 특징을 고려하여 데이터를 저장하는 방법을 자료구조라고 한다
- 특징이 있는 정보를 메모리에 효율적으로 저장 및 반환하는 방법으로, 데이터를 관리하는 방식
- 대용량일수록 메모리에 빨리 저장하고 빠르게 검색하여, 메모리를 효율적으로 사용하고 실행 시간을 줄일 수 있게 해 준다

## 파이썬에서의 자료구조
- 스택 = last in first out
- 큐 = first in first out
- 튜플 = 리스트와 같지만, 데이터의 변경을 허용 안 함
- 세트 = 데이터 중복을 허용하지 않고, 수학의 집한 연산을 지원
- 딕셔너리 = 키와 값 형태의 데이터를 저장, 키값은 다른 데이터와 중복을 허용 안 함
- collections 모듈 = 위에 열거된 여러 자료구조를 효율적으로 사용할 수 있도록 지원하는 파이썬 내장 모듈

# 스택과 큐

## 스택
- 마지막에 들어간 데이터가 가장 먼저 나오는 형태로, 데이터의 저장 공간을 구현
- 데이터 저장 = 푸시
- 데이터 추출 = 팝

## 큐
- 스택은 메모리가 시작하는 지점이 고정되어 있지만, 큐는 처음 값이 저장되는 메모리 주소가 값이 사용됨에 따라 계속 바뀌게 되어 구현에 좀 더 신경을 써야 한다, 파이썬에서는 스스로 구현됨

# 튜플과 세트

## 튜플
- 값을 변경하는 것이 불가능한 리스트
- 리스트형 데이터에 사용하는 함수 모두 사용 가능

## 세트
- 값을 순서 없이 저장하면서 중복을 불허하는 자료형
- 수학의 집합과 개념적으로 비슷
- 삭제나 변경 가능
- add() = 원소 하나 추가
- remove(), discard() = 원소 하나 삭제
- update() = 새로운 리스트를 그대로 추가
- clear() = 모든 변수 삭제
- s1.union(s2), s1|s2 = 합집합
- s1.intersection(s2), s1&s2 = 교집합
- s1.difference(se), s1-s2 = 차집합

# 딕셔너리

## 딕셔너리의 개념
- 데이터의 유일한 구분자를 키라는 이름으로 검색할 수 있게 하고, 실제 데이터를 값이라는 이름으로 쌍으로 저장하여 프로그래머가 데이터를 쉽게 찾을 수 있는 체계

## 파이썬에서의 딕셔너리
- 다양한 자료형이 들어갈 수 있다
- 할당 시 사용되는 키가 기존에 있던 값이라면 값이 변경되고, 기존에 없던 값이면 새로운 값이 할당된다

## 딕셔너리의 함수
- keys() = 키만 출력
- values() = 값만 출력
- items() = 키-값 쌍 출력

# collections 모듈

## deque 모듈

```python
from collections import deque

deque_list = deque()
for i in range(5):
    deque_list.append(i)

print(deque_list)
# deque([0, 1, 2, 3, 4])

print(deque_lsit.pop())
# 4
print(deque_list)
# deque([0, 1, 2, 3])

print(deque_list.rotate(2))
# deque([2, 3, 0, 1])

print(deque(reverse(deque_list)))
# deque([1, 0, 2, 3])

deque_list.extend([4, 5, 6])
print(deque_list)
# deque([1, 0, 2, 3, 4, 5 ,6])
deque_list.extendleft([7, 8, 9])
print(deque_list)
# deque([7, 8, 9, 1, 0, 2, 3, 4, 5, 6])
```

## OrderedDict 모듈

```python
from collections import OrderedDict

d = OrderdDict()
d['x'] = 100
d['y'] = 200
d['z'] = 300
d['l'] = 500

for k, v in d.items():
    print(k, v)
# x 100
# y 200
# z 300
# l 500

def sort_by_key(t):
    return t[0]

for k, v in OrderDict(sorted(d.items(), key = sort_by_key)).items():
    print(k, v)
# l 500
# x 100
# y 200
# z 300
```

## defaultdict 모듈

```python
from collections import defaultdict

d = defaultdict(lambda: 0)
print(d["first"])
# 0

s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)

for k, v in s:
    d[k].append(v)

print(d.items())
# dict_items([('yellow', [1, 3]), ('blue', [2, 4]), ('red', [1])])
```

## Counter 모듈

```python
from collections import Counter

text = list("gallahad")
c = Coutner(text)
print(c)
# Counter({'a':3, 'l':2, 'g':1, 'h':1, 'd':1})
print(c["a"])
# 3

c = Counter({'red':4, 'blue':2})
print(c.elements()))
# ['red', 'red', 'red', 'red', 'blue', 'blue']

c = Counter(cats = 4, dogs = 8)
print(list(c.elements()))
# ['cats', 'cats', 'cats', 'cats', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs', 'dogs']

c = Counter(a = 4, b = 2, c = 0, d = -2)
d = Counter(a = 1, b = 2, c = 3, d = 4)
print(c.subtract(d)) # c - d
# Counter({'a':3, 'b':0, 'c':-3, 'd':-6})

print(c + d)
# Counter({'a':5, 'b':4, 'c':3, 'd':2})
print(c & d)
# Counter({'b':2, 'a':1})
print(c | d)
# Counter({'a':4, 'd':4, 'c':3, 'b': 2})
```

## namedtuple 모듈

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(11, y=22)
print(p)
# Point(x=11, y=22)
print(p.x, p.y)
# (11, 22)
print(p[0] + p[1])
# 33
```

# Lab: 텍스트 마이닝 프로그램

```python
text = """A press lelease is the quickest and easiest way to get free publicity. If well written, a press release can result in multiple published articles about your firm and its products. And that can mean new prospects contaacting you asking you to sell to them.""".lower().split()

from collections import defaultdict

word_count = defaultdict(lambda: 0)
for word in text:
    word_count[word] += 1

from collections import OrderDict
for i, v in OrderedDict(sorted(word_count.items(), keylambda t: t[1], reverse=True)).items():
    print(i, v)
```

# 파이썬 스타일 코드의 이해

## 파이썬 스타일 코드의 개념

```python
colors = ['red', 'blue', 'green', 'yellow']
result = ''
for s in colors:
    result += s
print(result)
# redbluegreenyellow

result = ''.join(colors)
print(result)
# redbluegreenyellow
```

## 파이썬 스타일 코드를 사용하는 이유
- split(), join(), list comprehension, enumerate(), zip()같은 기본적인 개념부터 map()과 reduce()처럼 상위 개념까지 포함
- 다른 사람이 작성한 코드를 이해할 때 용이

# 문자열의 분리 및 결합

## 문자열의 분리: split() 함수

```python
items = 'zero one two three'.split()
print(items)
# ['zero', 'one', 'two', 'three']
```

## 문자열의 결함: join() 함수

```python
colors = ['red', 'blue', 'green', 'yellow']
result = ''.join(colors)
print(result)
# 'redbluegreenyellow'
```

# 리스트 컴프리헨션

## 리스트 컴프리헨션 다루기

```python
result = []
for i in range(10):
    result.append(i)

print(result)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

result = [i for i in range(10)]
print(result)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 리스트 컴프리헨션 용법

### 필터링

```python
result = [i for i in range(10) if i % 2 == 0]
print(result)
# [0, 2, 4, 6, 8]

result = [i if i % 2 == 0 else 10 for i in range(10)]
print(result)
# [0, 10, 2, 10, 4, 10, 6, 10, 8, 10]
```

### 중첩 반복문

```python
word_1 = "Hello"
word_2 = "World"
result = [i + j for i in word_1 for j in word_2]
print(result)
# ['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']

case_1 = ["A", "B", "C"]
case_2 = ["D", "E", "A"]
result = [i + j for i in case_1 for j in case_2 if not(i==j)]
print(result)
# ['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']
```

### 이차원 리스트

```python
words = 'The quick brown fox jums over the lazy dog'.split()
print(words)
# ['The', 'quick', 'brown', 'fox', 'jums', 'over', 'the', 'lazy', 'dog']

stuff = [[w.upper(), w.lower(), len(w)] for w in words]

for i in stuff:
    print(i)
# ['THE', 'the', 3]
# ['QUICK', 'quick', 5]
# ['BROWN', 'brown', 5]
# ['FOX', 'fox', 3]
# ['JUMS', 'jums', 4]
# ['OVER', 'over', 4]
# ['THE', 'the', 3]
# ['LAZY', 'lazy', 4]
# ['DOG', 'dog', 3]

case_1 = ["A", "B", "C"]
case_2 = ["D", "E", "A"]
result = [i + j for i in case_1 for j in case_2]
print(result)
# ['AD', 'AE', 'AA', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']

result = [[ i + j for i in case_1] for j in case_2]
print(result)
# [['AD', 'BD', 'CD'], ['AE', 'BE', 'CE'], ['AA', 'BA', 'CA']]
```

## 리스트 컴프리헨션의 성능
- 리스트 컴프리헨션은 내부적으로 잘 구성된 메모리 사용 방식으로, 기존 for 문보다 시간 면에서 효율적인 연산을 수행할 수 있다

# 다양한 방식의 리스트값 출력

## 리스트값에 인덱스를 붙여 출력: enumerate() 함수

```python
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
# 0 tic
# 1 tac
# 2 toe

print({i:j for i, j in enumerate('TEAMLAB is an academic institute located in South Korea.'.split())})
# {0: 'TEAMLAB', 1: 'is', 2: 'an', 3: 'academic', 4: 'institute', 5: 'located', 6: 'in', 7: 'South', 8: 'Korea.'}
```

## 리스트값을 병렬로 묶어 출력: zip() 함수

```python
alist = ['a1', 'a2', 'a3']
blist = ['b1', 'b2', 'b3']
for a, b in zip(alist,blist):
    print(a, b)
# a1 b1
# a2 b2
# a3 b3

a, b, c = zip((1, 2, 3), (10, 20, 30), (100, 200, 300))
print(a, b, c)
# (1, 10, 100) (2, 20, 200) (3, 30, 300)
print([sum(x) for x in zip((1, 2, 3), (10, 20, 30), (100, 200, 300))])
# [111, 222, 333]
```

# 람다 함수

## 람다 함수의 사용

```python
def f(x, y):
    return x + y

print(f(1, 4))
# 5

f = lambda x, y: x + y
print(f(1, 4))
# 5

print((lambda x: x + 1)(5))
# 6
```

## 람다 함수의 다양한 형태

```python
f = lambda x: x ** 2
print(f(3))
# 9

f = lambda x: x / 2
print(f(3))
# 1.5

print(f(3, 5))
# TypeError
```

# 맵리듀스

## map() 함수

```python
ex = [1, 2, 3, 4, 5]
f = lambda x: x ** 2
print(list(map(f, ex)))
# [1, 4, 9, 16, 25]
```

### 제너레이터의 사용
- list(map(함수 이름, 리스트 데이터)) 형태로 입력해야 리스트로 반환
- 제너레이터는 시퀀스 자료형의 데이터를 처리할 때, 실행 시점의 값을 생성하여 효율적으로 메모리를 관리할 수 있다는 장점이 있다

### 리스트 컴프리헨션과의 비교
- 굳이 람다 함수나 map() 함수를 이용하지 않아도 리스트 컴프리헨션 기법으로 얼마든지 같은 효과를 낼 수 있다

### 한 개 이상의 시퀀스 자료형 데이터의 처리

```python
ex = [1, 2, 3, 4, 5]
f = lambda x, y: x + y
print(list(map(f, ex, ex)))
# [2, 4, 6, 8, 10]

print([x + y for x, y in zip(ex, ex)])
# [2, 4, 6, 8, 10]
```

### 필터링(filtering) 기능

```python
print(list(map(lambda x: x ** 2 if x % 2 == 0 else x, ex)))
# [1, 4, 3, 16, 5]

print([x ** 2 if x % 2 == 0 else x for x in ex])
# [1, 4, 3, 16, 5]
```

## reduce() 함수

```python
from functools import reduce
print(reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]))
# 15
```

# 별표의 활용

## 별표의 사용

```python
def asterisk_test(a, *args):
    print(a, args)
    print(type(args))

asterisk_test(1, 2, 3, 4, 5, 6)
# 1 (2, 3, 4, 5, 6)
# <class 'tuple'>

def asterisk_test(a, **kargs):
    print(a, kargs)
    print(type(kargs))

asterisk_test(1, b=2, c=3, d=4, e=5, f=6)
# 1 {'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
# <class 'dict'>
```

## 별표의 언패킹 기능

```python
def asterisk_test(a, args):
    print(a, *args)
    print(type(args))

asterisk_test(1, (2, 3, 4, 5, 6))
# 1 2 3 4 5 6
# <class 'tuple'>

def asterisk_test(a, *args):
    print(a, args)
    print(type(args))

asterisk_test(1, *(2, 3, 4, 5, 6))
# 1 (2, 3, 4, 5, 6)
# <class 'tuple'>

a, b, c = ([1, 2], [3, 4], [5, 6])
print(a, b, c)
# [1, 2], [3, 4], [5, 6]

data = ([1, 2], [3, 4], [5, 6])
print(*data)
# [1, 2], [3, 4], [5, 6]

for data in zip(*[[1, 2], [3, 4], [5, 6]]):
    print(data)
    print(type(data))

# (1, 3, 5)
# <class 'tuple'>
# (2, 4, 6)
# <class 'tuple'>

def asterisk_test(a, b, c, d,):
    print(a, b, c, d)

data = {"b":1, "c":2, "d":3}
asterisk_test(10, **data)
# 10 1 2 3
```

# 선형대수학

## 백터와 행렬의 개념

### 백터(vector)
- 어떤 정보를 표현하는 방법일는 관점에서 볼 때, 3개 이상의 정보를 사용해야 하는 경우가 많다
- 여러 개의 데이터를 하나의 정보에 표현하는 것

### 행렬(matrix)
- 1개 이상의 벡터 모임
- 행렬에서 행 또는 열은 하나의 대상에 대한 정보를 표현한 것이며, 그 모음이 바로 행렬
- m 개의 행과 n 개의 열로 구성되고 'm x n 행렬'이라고 표기하며 'm by n'으로 읽는다
- 메트릭스의 각 요소의 값을 표시할 때는 행렬 A 의 i 행, j 열의 값을 'A 의 ij 번재 값'이라고 하고, 'a_ij'로 표시

## 파이썬 스타일 코드로 표현한 벡터

```python
# 리스트로 표현한 경우
vector_a = [1, 2, 10]
# 튜플로 표현한 경우
vector_b = (1, 2, 10)
# 딕셔너리로 표현한 경우
vector_c = {'x':1, 'y':1, 'z':10}
```

### 벡터의 연산

```python
u = [2, 2]
v = [2, 3]
z = [3, 5]
result = []

for i in range(len(u)):
    result.append(u[i] + v[i] + z[i])

print(result)
# [7, 10]

u = [2, 2]
v = [2, 3]
z = [3, 5]

result = [sum(t) for t in zip(u, v, z)]
print(result)
# [7, 10]

print([t for t in zip(u, v, z)]))
# [(2, 2, 3), (2, 3, 5)]
```

### 별표를 사용한 함수화

```python
def vector_addition(*args):
    return [sum(t) for t in zip(*args)]

print(vector_addition(u, v, z))
# [7, 10]

row_vectors = [[2, 2], [2, 3], [3, 5]]
print(vector_addition(*row_vectors))
# [7, 10]
```

### 스칼라 - 벡터 연산

```python
u = [1, 2, 3]
v = [4, 4, 4]
alpha = 2

result = [alpha * sum(t) for t in zip(u, v)]
print(result)
# [10, 12, 14]
```

## 파이썬 스타일 코드로 표현한 행렬

```python
# 리스트로 표현한 경우
matrix_a = [[3, 6], [4, 5]]
# 튜플로 표현한 경우
matrix_b = [(3, 6), (4, 5)]
# 딕셔너리로 표현한 경우
matrix_c = {(0, 0):3, (0, 1):6, (1, 0):4, (1, 1):5}
```

### 행렬의 연산

```python
matrix_a = [[3, 6], [4, 5]]
matrix_b = [[5, 8], [6, 7]]
result = [[sum(row) for row in zip(*t)] for t in zip(matrix_a, matrix_b)]
print(result)
# [[8, 14], [10, 12]]

print([t for t in zip(matrix_a, matrix_b)])
# [([3, 6], [5, 8]), ([4, 5], [6, 7])]
```

### 행렬의 동치
- 동치 = 두 개의 행렬이 같은지를 나타내는 표현

```python
matrix_a = [[1, 1], [1, 1]]
matrix_b = [[1, 1], [1, 1]]
print(all([row[0] == value for t in zip(matrix_a, matrix_b) for row in zip(*t) for value i row]))
# True

matrix_b = [[5, 8], [6, 7]]
print(all([all(row[0] == values for value in row]) for t in zip(matrix_a, matrix_b) for row in zip(*t)]))
# False

print(any([False, False, False]))
# False
print(any([False, True, False]))
# True
print(all([False, True, True]))
# False
print(all([True, True, True]))
# True

print([[row[0] == value for value in row] for t in zip(matrix_a, matrix_b) for row in zip(*t)])
# [[True, False], [True, False], [True, False], [True, False]]
```

### 전치 행렬(transpose matrix)
- 전치 행렬은 주어진 m x n 의 행렬에서 행과 열을 바꾸어 만든 행렬

```python
matrix_a = [[1, 2, 3], [4, 5, 6]]
result = [[element for element in t] for t in zip(*matrix_a)]
print(result)
# [[1, 4], [2, 5], [3, 6]]

print([t for t in zip(*matrix_a)])
# [(1, 4), (2, 5), (3, 6)]
```

### 행렬의 곱셈
- 앞 행렬의 열과 뒤 행렬의 행을 선형 결합
- 앞 행렬의 열과 뒤 행렬의 행의 크기가 같아야 한다

```python
matrix_a = [[1, 1, 2], [2, 1, 1]]
matrix_b = [[1, 1], [2, 1], [1, 3]]
result = [[sum(a * b for a, b in zip(row_a, column_b)) for column_b in zip(*matrix_b)] for row_a in matrix_a]
print(result)
# [[5, 8], [5, 6]]
```

# 객체 지향 프로그래밍의 이해

## 객체 지향 프로그래밍을 배우는 이유
- 남이 만든 코드를 재사용하고 싶을 때 사용하는 대표적인 방법

## 객체와 클래스
- 객체 = 실생활에 존재하는 실제적인 물건 또는 개념을 뜻하며, 속성과 행동으로 구성된다
- 속성은 변수, 행동은 함수로 정의
- 클래스 = 객체가 가져야 할 기본 정보를 담은 코드

# 파이썬의 객체 지향 프로그래밍

## 클래스 구현하기
- class ClassName(상속받는객체명):
- 클래스의 이름은 snake_case 나 CamelCase 를 자주 사용

### 속성의 선언

```python
class SoccerPlayer(boject):
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number
```

- \_\_init__() = 해당 class 에서 사용할 변수를 정의하는 함수, 첫번째 매개변수는 반드시 self 변수를 사용
- self 변수 = 클래스에서 생성된 인스턴스에 접근하는 예약어, 생성된 인스턴스를 지정하는 변수
- self 뒤에 매개변수들은 실제로 클래스가 가진속성, 실제 생성된 인스턴스에 할당된다
- self.name = name 으로 할당, 생성된 인스턴스에 있는 name 변수에 매개변수로 입력된 name이라는 값을 할당한다는 뜻
- 클래스의 변수는 self.변수이름 으로 \_\_init()__ 함수에서 자유롭게 생성
- 파이썬은 인터프리터 언어이고 동적 타이핑 언어이므로, 클래스 내 다른 함수에서도 이같은 속성의 생성은 가능하나 일반적으로 \_\_init()__ 함수 내에서만 새로운 속성을 생성해야 다른 프로그래머가 헷갈리지 않을 것

### 함수의 선언

```python
class SoccerPlayer(objec):
    def change_back_number(self, new_number):
        print("선수의 등번호를 변경한다: From %d to %d" % (self.back_number, new_number))
        self.back_number = new_number
```

- self 매개변수를 반드시 넣어야 한다
- self 가 있어야만 실제로 인스턴스가 사용할 수 있는 함수로 선언된다

### _의 쓰임
- _ 1개는 이후로 쓰이지 않을 변수에 특별한 이름을 부여하고 싶지 ㅇ낳ㅇ르 때 사용
- __ 2개는 특수한 예약 함수나 변수에 사용
- \_\_str__() 함수는 클래스로 인스턴스를 생성했을 때, 그 인스턴스 자체를 print() 함수로 화면에 출력하면 나오는 값을 뜻한다

## 인스턴스 사용하기
- 인스턴스 = 클래스에서 실제적인 데이터가 입력되어 사용할 수 있는 형태의 객체
- 클래스 이름을 사용하여 호출 > \_\_init__() 함수의 매개변수에 맞추어 값을 입력, 초깃값 지정 등도 사용 가능 > self 변수는 아무런 값도 할당되지 않는다

```python
# 전체 SoccerPlayer 코드
class SoccerPlayer(object):
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number
    def change_back_number(self, new_number):
        print("선수의 등번호를 변경한다: From %d to %d" % (self.back_number, new_number))
        self.back_number = new_number
    def __str__(self):
        return "Hello, My name is %s. i play in %s in center." % (self.name, self.position)

# SoccerPlayer 를 사용하는 instance 코드
jinhyun = SoccerPlayer("Jinhyun", "MF", 10)

print("현재 선수의 등번호는:", jinhyun.back_number)
jinhyun.change_back_number(5)
print("현재 선수의 등번호는:", jinhyun.back_number)
# 현재 선수의 등번호는: 10
# 선수의 등번호를 변경한다: From 10 to 5
# 현재 선수의 등번호는: 5
```

- 인스턴스가 생성된 후에는 해당 인스턴스의 이름으로 값을 할당하거나 함수를 부르면 되지만, 클래스 내에서는 self 로 호출된다
- print(jinhyun) 을 실행할 경우 \_\_str__ 함수의 내용이 출력

## 클래스를 사용하는 이유
- 다른 사람이 손쉽게 사용할 수 있도록 설계하기 위해
- 코드를 좀 더 손쉽게 선언할 수 있다
- 모든 코드를 객체 지향으로 작성할 필요가 없으니 적재적소에 사용할 것

# Lab: 노트북 프로그램 만들기

```python
class Note(object):
    def __init__(self, contents = None):
        self.contents = contents

    def write_contents(self, contents):
        self.contents = contents

    def remove_all(self):
        selfcontents = ""

    def __str__(self):
        return self.contents

class NoteBook(object):
    def __init_(self, title):
        self.title = title
        self.page_number = 1
        self.notes = {}

    def add_note(self, note, page = 0):
        if self.page_number < 300:
            if page == 0:
                self.notes[self.page_number] = note
                self.page_number += 1
            else:
                self.notes = {page : note}
                self.page_number += 1
        else:
            print("페이지가 모두 채워졌다.")
            
    def remove_note(self, page_number):
        if page_number in self.notes.keys():
            return self.notes.pop(page_number)
        else:
            print("해당 페이지는 존재하지 않는다.")
            
    def get_number_of_pages(self):
        return len(self.notes.keys())
    
from notebook import Note
from notebook import NoteBook

good_sentence = """세상 사는 데 도움이 되는 명언, 힘이 되는 명언, 용기를 주는 명언, 위로되는
명언, 좋은 명언 100가지. 자주 보면 좋을 것 같아 선별했습니다."""
note_1 = Note(good_sentence)

good_sentence = """삶이 있는 한 희망은 있다. - 키케로"""
note_2 = Note(good_sentence)

good_sentence = """하루에 3시간을 걸으면 7년 후네 지구를 한 바퀴 돌 수 있다. - 새뮤얼 존
슨"""
note_3 = Note(good_sentence)

good_sentence = """행복의 문이 하나 닫히면 다른 문이 열린다. 그러나 우리는 종종 닫힌 문을
멍하니 바라보다가 우리를 향해 열린 문을 보지 못하게 된다. - 헬렌 켈러"""
note_4 = Note(good_sentence)

wise_saying_notebook = NoteBook("명언 노트")
wise_saying_notebook.add_note(note_1)
wise_saying_notebook.add_note(note_2)
wise_saying_notebook.add_note(note_3)
wise_saying_notebook.add_note(note_4)

print(wise_saying_notebook.get_number_of_pages())
```

# 객체 지향 프로그래밍의 특징

## 상속
- 부모 클래스에 정의된 속성과 메서드를 자식 클래스가 물려받아 사용하는 것

```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Korean(Person):
    pass

first_korean = Korean("Sungchul", 35)
print(first_korean.name)
# Sungchul

class Persont(object):
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender

    def about_me(self): # 메서드 선언
        print("제 이름은", self.name, "이고요, 제 나이는", str(self.age), "살입니다.")

class Employee(Person): # 부모 클래스 Person으로부터 상속
    def __init__(self, name, age, gender, salary, hire_date):
        super().__intit__(name, age, gender) # 부모 객체 사용
        self.salary = salary
        self.hire_date = hire_date # 속성값 추가

    def do_work(self): # 새로운 메서드 추가
        print("열심히 일을 한다")

    def about_me(self): # 부모 클래스 함수 재정의 = 오버라이딩 = 상속 시 함수 이름과 필요한 매개변수는 유지하면서 함수의 수행 코드를 변경하는 것
        super().about_me() # 부모 클래스 함수 재사용
        print("제 급여는", self.salary, "원이고, 제 입사일은", self.hire_date, "입니다.")
```

## 다형성
- 같은 이름의 메서드가 다른 기능을 할 수 있도록 하는 것
- 각각 클래스에서 구현되는 내부 로직에 차이가 있는데, 이를 함수의 다형성이라고 한다

## 가시성
- 객체의 정보를 볼 수 있는 레벨을 조절하여 객체의 정보접근을 숨기는 것
- 캡슐화 = 클래스 간 간섭 및 정보 공유를 최소화하여 개별 클래스가 단독으로 동작하기 위해, 각 클래스가 강하게 연결되어 있을 경우 독립적으로 사용 어려움, 인터페이스만 이해하면 사용할 수 있기 위함
- 정보 은닉을 어떻게 할 것인가를 코드 레벨에서 조절
- 클래스 내부용으로 변수 사용시 __변수명 형태로 변수 선언, 가시성을 클래스 내로 한정하면서 값이 다르게 들어가는 것을 막을 수 있다
- 데코레이터 = 클래스의 각 메서드 상단에 삽입하여 해당 메서드의 기능을 추가하는 파이썬 문법
- 은닉된 정보를 데코레이터를 통해 외부에서 사용 가능

# 모듈과 패키지의 이해

## 모듈의 개념
- 하나하나 연결해 어떤 목적을 가진 프로그램을 만드는 작은 프로그램
- 각 모듈 역시 저마다 역할이 있고, 서로 다른 모듈과 인터페이스만 연결되면 사용할 수 있다
- 인터페이스 = 함수에서 매개변수를 입력하는 약속, 모듈을 사용하기 위해 모듈 간의 연결을 위한 약속
- import = 모듈을 호출하는 명령어, 모듈을 메모리에 올리라는 듯

## 패키지의 개념
- 모듈의 묶음
- from = 모듈을 호출하기 위해 패키지부터 호출하는 명령여

# 모듈 만들기

## 모듈 만들기 실습

```python
# fah_converter.py

def covert_c_to_f(celcius_value):
    return celcius_value * 9.0 / 5 + 32

# module_ex.py

import fah_converter

print("Enter a celsius value:")
celsius = float(input())
fahrenheit = fah_converter.covert_c_to_f(celsius)
print("That's", fahrenheit, "degrees Fahrenheit.")
# Enter a celsius value:
# 10
# That's 50.0 degrees Fahrenheit.
```

## 네임스페이스
- 모듈의 호출 범위를 지정

```python
# 모듈 이름에 알리아스를 생성하여 모듈 안으로 코드를 호출하는 방법

import fah_converter as fah
print(fah.convert_c_to_f(41.6))
# 106.88000000000001

# from 구문을 사용하여 모듈에서 특정 함수 또는 클래스만 호출하는 방법

from fah_converter import covert_c_to_f
print(covert_c_to_f(41.6))
# 106.88000000000001

# 해당 모듈 안에 있는 모든 함수, 클래스, 변수를 가져오는 별표를 사용하는 것

from fah_converter import *
print(covert_c_to_f(41.6))
# 106.88000000000001
```

## 내장 모듈의 사용

### random 모듈

```python
import random
print(random.randint (0, 100)) # 0~100 사이의 정수 난수를 생성
# 7
print(random.random()) # 일반적인 난수 생성
# 0.056550421789531846
```

### time 모듈

```python
import time
print(time.localtime()) # 현재 시각 출력
# time.struct_time(tm_year=2023, tm_mon=2, tm_mday=28, tm_hour=16, tm_min=43, tm_sec=7, tm_wday=1, tm_yday=59, tm_isdst=0)
```

### urllib 모듈

```python
import urllib.request
response = urllib.request.urlopen("http://theteamlab.io")
print(response.read())
```

# 패키지 만들기

## 패키지의 구성
- 대형 프로젝트를 수행하기 위한 모듈의 묶음
- 모듈은 하나의 파일로 이루어져 있고, 패키지는 파일이 포함된 디렉터리로 구성된다
- 여러개의 .py 파일이 하나의 디렉터리에 들어가 있는 것을 패키지라고 한다

## 패키지 만들기 실습

### 1단계: 디렉터리 구성하기

```python
mkdir roboadvisor
cd roboadvisor
mkdir crawling
mkdir database
mkdir analysis
```

### 2단계: 디렉터리별로 필요한 모듈 만들기
- 각각의 디렉터리를 하나의 패키지로 선언하기 위해서 각 디렉터리에 \_\_init__.py 를 추가

```python
# analysis > series.py

def series_test():
    print("series")

# analysis > statics.py

def statics_test():
    print("statics")

# python shell
from roboadvisor.analysis import series
series.seiries_test()
# series
```

- 코드를 실행하면 roboadvisor 디렉터리 안에는 \_\_pycache__ 라는 디렉터리가 생성되는데, 이는 파이썬의 언어적 특성으로 생기는 결과
- \_\_pycache__ 디렉터리에 해당 프로그램이 작동될 때 사용하기 위한 모듈들을 컴파일하고, 그 결과를 저장
- 생성 후 해당 모듈을 수정해도 결과가 반영되지 않고 해당 프로그램 또는 파이썬 셸이 완전히 종료된 후 수정해야 해당 모듈의 결과를 반영할 수 있다

### 3단계: 디렉터리별로 \_\_init__.py 구성하기
- \_\_init__ 은 해당 디렉터리가 파이썬의 패키지라고 선언하는 초기화 스크립트로 파이썬의 거의 모든 라이브러리에 있다
- 패키지 개발자, 설치 시 확인해야 할 내용 등 메타데이터라고 할 수 있는 내용을 담고 있다

```python
# roboadvisor > __init__.py

import analysis
import crawling
import database

__all__ = ['analysis', 'crawling', 'database']

# analysis > __init__.py

from . import series
from . import statics

__all__ = ['series', 'statics']
```

### 4단계: \_\_main__.py 파일 만들기
- 패키지 자체를 실행하기 위해서 생성

```python
# roboadvisor > __main__.py

from analysis.series import series_test
from crawling.parser import parser_test

if __name__ == '__main__':
    series_test()
    parser_test()
```

### 5단계: 실행하기(패키지 이름만으로 호출하기)

```python
# 최상위 디렉터리에서 실행
python roboadvisor
series
parser
```

## 패키지 네임스페이스

### 절대 참조
- from roboadvisor.analysis import series
- 전체 경로를 모두 입력하는 것을 절대 참조라고 한다

### 상대 참조
- 현재 디렉터리를 기준으로 모듈을 호출하는 것

```python
from .series import series_test
from ..crawling.parser import parser_test
```

- . = 현재 디렉터리
- .. = 부모 디렉터리

# 가상환경 사용하기

## 가상환경의 개념
- 패키지를 설치할 때 서로 다른 프로젝트가 영향을 받지 않도록 독립적인 프로젝트 수행 환경을 구성하는 것을 가상환경이라고 한다

## 가상환경 설정하기

### 가상환경 만들기
- conda create -n my_project python=3.4

### 가상환경 실행하기
- activate my_project
- deactivate

### 가상환경 패키지 설치하기
- conda install matplotlib

### 가상환경 패키지 실습하기

```python
import matpplotllib.pyplot as plt
plt.plot([1, 2, 3, 4])
plt.ylabel('some numbers')
plt.show()
```

# 예외 처리

## 예외의 개념의 사례